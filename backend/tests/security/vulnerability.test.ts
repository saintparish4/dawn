import { describe, expect, it, beforeEach } from "@jest/globals";
import request from "supertest";
import { app } from "../../src/app";
import jwt from "jsonwebtoken";

describe("Security Vulnerability Tests", () => {
  describe("SQL Injection Protection", () => {
    it("should prevent SQL injection in email field", async () => {
      // Arrange
      const maliciousData = {
        email: "test@example.com'; DROP TABLE merchants; --",
        password: "TestPassword123!",
        businessName: "Test Business",
        businessType: "ecommerce",
      };

      // Act
      const response = await request(app)
        .post("/api/v1/auth/register")
        .send(maliciousData);

      // Assert
      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);

      // Verify table still exists by attempting a valid registration
      const validResponse = await request(app)
        .post("/api/v1/auth/register")
        .send({
          email: "valid@example.com",
          password: "TestPassword123!",
          businessName: "Valid Business",
          businessType: "ecommerce",
        });

      expect(validResponse.status).toBe(201);
    });

    it("should prevent SQL injection in search parameters", async () => {
      // Arrange
      const validToken = jwt.sign(
        {
          id: "test",
          email: "test@example.com",
          merchantId: "test",
          role: "merchant",
        },
        process.env.JWT_SECRET!
      );

      // Act
      const response = await request(app)
        .get("/api/v1/payments")
        .set("Authorization", `Bearer ${validToken}`)
        .query({ page: "1; DROP TABLE payments; --" });

      // Assert
      expect(response.status).toBe(200); // Should handle gracefully
      expect(response.body.success).toBe(true);
    });
  });

  describe("XSS Protection", () => {
    it("should sanitize script tags in business name", async () => {
      // Arrange
      const xssData = {
        email: "xss-test@example.com",
        password: "TestPassword123!",
        businessName: '<script>alert("XSS")</script>Evil Business',
        businessType: "ecommerce",
      };

      // Act
      const response = await request(app)
        .post("/api/v1/auth/register")
        .send(xssData);

      // Assert
      expect(response.status).toBe(201);
      expect(response.body.data.businessName).not.toContain("<script>");
      expect(response.body.data.businessName).not.toContain("alert");
    });
  });

  describe("Authentication Security", () => {
    it("should reject requests with tampered JWT tokens", async () => {
      // Arrange
      const validToken = jwt.sign(
        {
          id: "test",
          email: "test@example.com",
          merchantId: "test",
          role: "merchant",
        },
        process.env.JWT_SECRET!
      );

      // Tamper with the token
      const tamperedToken = validToken.slice(0, -5) + "XXXXX";

      // Act
      const response = await request(app)
        .get("/api/v1/merchants/profile")
        .set("Authorization", `Bearer ${tamperedToken}`);

      // Assert
      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe("Invalid token.");
    });

    it("should reject expired JWT tokens", async () => {
      // Arrange
      const expiredToken = jwt.sign(
        {
          id: "test",
          email: "test@example.com",
          merchantId: "test",
          role: "merchant",
        },
        process.env.JWT_SECRET!,
        { expiresIn: "-1h" } // Expired 1 hour ago
      );

      // Act
      const response = await request(app)
        .get("/api/v1/merchants/profile")
        .set("Authorization", `Bearer ${expiredToken}`);

      // Assert
      expect(response.status).toBe(401);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe("Invalid token.");
    });

    it("should enforce role-based access control", async () => {
      // Arrange
      const merchantToken = jwt.sign(
        {
          id: "test",
          email: "test@example.com",
          merchantId: "test",
          role: "merchant",
        },
        process.env.JWT_SECRET!
      );

      // Act - Try to access admin endpoint with merchant token
      const response = await request(app)
        .get("/api/v1/system/status")
        .set("Authorization", `Bearer ${merchantToken}`);

      // Assert
      expect(response.status).toBe(403);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe("Access denied. Admin access required.");
    });
  });

  describe("Input Validation Security", () => {
    it("should reject oversized request payloads", async () => {
      // Arrange
      const largeString = "A".repeat(11 * 1024 * 1024); // 11MB string
      const oversizedData = {
        email: "test@example.com",
        password: "TestPassword123!",
        businessName: largeString,
        businessType: "ecommerce",
      };

      // Act
      const response = await request(app)
        .post("/api/v1/auth/register")
        .send(oversizedData);

      // Assert
      expect(response.status).toBe(413); // Payload too large
    });

    it("should validate cryptocurrency addresses", async () => {
      // Arrange
      const validToken = jwt.sign(
        {
          id: "test",
          email: "test@example.com",
          merchantId: "test",
          role: "merchant",
        },
        process.env.JWT_SECRET!
      );

      const invalidAddressData = {
        walletAddress: "invalid-eth-address",
        settlementAddress: "0x123", // Too short
      };

      // Act
      const response = await request(app)
        .patch("/api/v1/merchants/profile")
        .set("Authorization", `Bearer ${validToken}`)
        .send(invalidAddressData);

      // Assert
      expect(response.status).toBe(400);
      expect(response.body.success).toBe(false);
      expect(response.body.error).toContain("walletAddress");
    });
  });

  describe("Rate Limiting Security", () => {
    it("should prevent brute force attacks on login", async () => {
      // Arrange
      const loginAttempts = Array(10).fill({
        email: "target@example.com",
        password: "wrongpassword",
      });

      // Act
      const responses = await Promise.all(
        loginAttempts.map((data) =>
          request(app).post("/api/v1/auth/login").send(data)
        )
      );

      // Assert
      const rateLimitedResponses = responses.filter((r) => r.status === 429);
      expect(rateLimitedResponses.length).toBeGreaterThan(0);

      const lastResponse = responses[responses.length - 1];
      expect(lastResponse.status).toBe(429);
      expect(lastResponse.body.error).toContain(
        "Too many authentication attempts"
      );
    });
  });
});
